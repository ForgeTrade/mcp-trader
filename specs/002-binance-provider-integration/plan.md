# Implementation Plan: Binance Provider Integration

**Branch**: `002-binance-provider-integration` | **Date**: 2025-10-18 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/002-binance-provider-integration/spec.md`

## Summary

This feature converts the existing mcp-binance-rs stdio MCP server into a gRPC provider that integrates with the MCP Gateway system. The provider will expose 16 cryptocurrency trading tools (market data, account management, order execution), 4 resources, and 2 AI prompt templates through the gateway's unified interface. The technical approach involves wrapping the mcp-binance-rs functionality with a gRPC server layer that implements the provider.proto contract, while maintaining the existing Binance API client logic and tool implementations.

## Technical Context

**Language/Version**: Rust 1.75+ (provider), Python 3.11+ (gateway integration tests)
**Primary Dependencies**:
- Provider: tonic 0.9 (gRPC), prost 0.11 (protobuf), rmcp 0.8.1 (MCP SDK), tokio 1.48 (async runtime), reqwest 0.12 (HTTP client)
- Gateway: existing grpcio 1.75+ (Python gRPC client)

**Storage**: N/A (stateless provider, ephemeral order book cache when WebSocket feature enabled)
**Testing**: cargo test (Rust provider unit tests), pytest (Python gateway integration tests)
**Target Platform**: Linux server x86_64 (primary), cross-platform (macOS, Windows) for development
**Project Type**: Multi-project distributed system (gateway orchestrator + provider services)
**Performance Goals**:
- Market data queries: <2s end-to-end latency
- Order execution: <3s end-to-end latency
- Real-time order book updates: <200ms when WebSocket enabled
- Provider startup: <5s to full capability registration

**Constraints**:
- Binance API rate limits (1200 weight/minute for REST, 20 concurrent WebSocket connections)
- Fail-fast timeout strategy (2-3s, no automatic retries)
- No state persistence (all data sourced from Binance API on-demand)
- API credentials managed via environment variables (12-Factor compliance)

**Scale/Scope**:
- 16 tools exposed through gRPC interface
- Support for testnet and production Binance environments
- Optional orderbook feature for advanced trading (20 symbol limit for WebSocket tracking)
- Single provider instance per gateway deployment

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Simplicity and Readability
✅ **PASS** - The plan leverages existing mcp-binance-rs code (already simple and well-structured) and adds a thin gRPC wrapper layer. Tool logic remains unchanged, minimizing new code complexity.

### Principle II: Library-First Development
✅ **PASS** - Using established libraries:
- Tonic (de facto Rust gRPC library, 7k+ stars)
- Prost (standard protobuf for Rust)
- rmcp SDK (official MCP SDK for Rust)
- Existing hello-go provider architecture as reference pattern

### Principle III: Justified Abstractions
✅ **PASS** - The gRPC abstraction is justified by concrete need: the gateway requires a standardized provider.proto interface. No speculative abstractions introduced.

### Principle IV: DRY Principle
✅ **PASS** - Tool implementations (16 tools) are reused from mcp-binance-rs without duplication. Protobuf contract shared across all providers via pkg/proto/. Capability discovery logic follows hello-go pattern.

### Principle V: Service and Repository Patterns
✅ **PASS** - Existing mcp-binance-rs already uses:
- Repository pattern: `binance::client` module isolates API calls
- Service pattern: Tool handlers encapsulate business logic
No changes needed, patterns preserved in gRPC wrapper.

### Principle VI: 12-Factor Methodology
✅ **PASS** - Implementation follows 12-Factor:
1. Codebase: Single monorepo with provider subdirectory
2. Dependencies: Cargo.toml explicit dependencies
3. Config: API credentials from BINANCE_API_KEY/SECRET env vars
4. Backing services: Binance API treated as attached resource
5-12: Stateless process, port binding (gRPC), logging to stdout, fast startup/shutdown

### Principle VII: Minimal Object-Oriented Programming
✅ **PASS** - Rust naturally favors composition over inheritance. Provider uses structs with trait implementations (ServerHandler), no class hierarchies. Tool handlers are procedural functions.

**Pre-Design Status**: ✅ ALL GATES PASSED

## Project Structure

### Documentation (this feature)

```
specs/002-binance-provider-integration/
├── plan.md              # This file
├── research.md          # Technology decisions and patterns
├── data-model.md        # Entity definitions
├── quickstart.md        # Developer setup guide
├── contracts/           # Shared protobuf contract (reference to pkg/proto/)
│   └── provider.proto   # (symlink or documentation reference)
└── tasks.md             # (Generated by /speckit.tasks command)
```

### Source Code (repository root)

```
mcp-trader/
├── pkg/
│   ├── proto/
│   │   └── provider.proto          # Shared gRPC contract (already exists)
│   └── schemas/                    # JSON schemas (already exists)
│
├── providers/
│   ├── hello-go/                   # Existing reference implementation
│   └── binance-rs/                 # NEW: Binance provider
│       ├── src/
│       │   ├── main.rs             # Binary entrypoint
│       │   ├── lib.rs              # Library exports
│       │   ├── grpc/               # NEW: gRPC server layer
│       │   │   ├── mod.rs          # BinanceProviderServer struct
│       │   │   ├── capabilities.rs # ListCapabilities RPC
│       │   │   ├── tools.rs        # Invoke RPC (routes to mcp handlers)
│       │   │   ├── resources.rs    # ReadResource RPC
│       │   │   └── prompts.rs      # GetPrompt RPC
│       │   ├── pb/                 # NEW: Generated protobuf code
│       │   │   ├── mod.rs
│       │   │   ├── provider.rs     # (auto-generated from provider.proto)
│       │   │   └── provider.tonic.rs
│       │   ├── binance/            # EXISTING: Binance API client
│       │   │   ├── client.rs       # (preserved from mcp-binance-rs)
│       │   │   ├── types.rs
│       │   │   └── websocket.rs
│       │   ├── tools/              # EXISTING: Tool implementations
│       │   │   └── *.rs            # (preserved from mcp-binance-rs)
│       │   ├── orderbook/          # EXISTING: Optional WebSocket feature
│       │   │   └── *.rs            # (preserved from mcp-binance-rs)
│       │   ├── config/             # EXISTING: Configuration
│       │   │   └── *.rs
│       │   └── error.rs            # EXISTING: Error types
│       ├── build.rs                # NEW: Tonic protobuf codegen
│       ├── Cargo.toml              # NEW: Dependencies
│       └── README.md               # NEW: Provider documentation
│
├── mcp-gateway/                    # EXISTING: Python gateway
│   ├── mcp_gateway/
│   │   └── adapters/
│   │       └── grpc_client.py      # (already supports provider.proto)
│   └── providers.yaml              # UPDATE: Add binance-rs entry
│
├── Makefile                        # UPDATE: Add binance-rs targets
└── README.md                       # UPDATE: Document Binance provider
```

**Structure Decision**: Multi-project distributed architecture following existing hello-go provider pattern. The binance-rs provider runs as a standalone gRPC server process (similar to hello-go's architecture), while the Python gateway orchestrates provider communication. This maintains separation of concerns and allows independent scaling/deployment of providers.

## Complexity Tracking

*No constitution violations - all gates passed. This section intentionally left empty.*

---

## Post-Design Constitution Re-Check

*GATE: Re-evaluation after Phase 1 design (research, data model, contracts, quickstart complete)*

### Principle I: Simplicity and Readability
✅ **PASS** - Design maintains simplicity:
- Adapter pattern wraps existing mcp-binance-rs code without modification
- gRPC layer consists of simple struct with trait implementation
- No complex state machines or inheritance hierarchies
- Clear separation: grpc/ (new) vs binance/ + tools/ (existing, unchanged)

### Principle II: Library-First Development
✅ **PASS** - All technology choices leverage battle-tested libraries:
- Tonic 0.9 for gRPC (industry standard, actively maintained)
- Prost 0.11 for protobuf (de facto Rust standard)
- Serde for JSON serialization (ubiquitous in Rust)
- Existing rmcp SDK from mcp-binance-rs (official MCP for Rust)
- No custom RPC framework, no custom serialization

### Principle III: Justified Abstractions
✅ **PASS** - Every abstraction serves a concrete need:
- gRPC wrapper: Required by gateway contract
- Json message wrapper: Enables schema-flexible payloads
- Capability builder: DRY for ListCapabilities response
- Resource URI parser: Already exists in mcp-binance-rs, reused as-is
- No speculative abstractions added in design phase

### Principle IV: DRY Principle
✅ **PASS** - Design eliminates duplication:
- Protobuf contract shared via pkg/proto/ (single source of truth)
- Tool implementations reused from mcp-binance-rs (zero duplication)
- JSON schemas embedded at compile time (no runtime regeneration)
- Capability discovery follows hello-go pattern (consistent approach)
- Error handling conventions shared across providers

### Principle V: Service and Repository Patterns
✅ **PASS** - Existing patterns preserved and enhanced:
- Repository pattern: `binance::client` module unchanged (API calls isolated)
- Service pattern: Tool handlers unchanged (business logic encapsulated)
- gRPC server: Acts as thin adapter, delegates to existing services
- Separation of concerns maintained: adapter → service → repository

### Principle VI: 12-Factor Methodology
✅ **PASS** - Design fully compliant:
1. **Codebase**: providers/binance-rs/ in monorepo
2. **Dependencies**: Cargo.toml with explicit versions
3. **Config**: BINANCE_API_KEY/SECRET from env vars (never hardcoded)
4. **Backing services**: Binance API as attached resource (URL configurable)
5. **Build/release**: `cargo build --release` produces single binary
6. **Processes**: Stateless gRPC server (orderbook cache is ephemeral)
7. **Port binding**: gRPC listens on configurable port (50052 default)
8. **Concurrency**: Tokio async runtime (work-stealing scheduler)
9. **Disposability**: Fast startup (<5s), graceful shutdown (SIGTERM handling)
10. **Dev/prod parity**: Same binary, env vars control testnet vs production
11. **Logs**: All logging to stdout via tracing crate
12. **Admin tasks**: No admin processes (provider is single-purpose)

### Principle VII: Minimal Object-Oriented Programming
✅ **PASS** - Design avoids unnecessary OOP:
- Structs with trait implementations (idiomatic Rust, not OOP)
- Tool handlers are async functions (procedural, not methods)
- No inheritance hierarchies
- No abstract base classes or virtual methods
- Composition over inheritance throughout

**Post-Design Status**: ✅ ALL GATES PASSED

**Summary**: The design maintains full constitution compliance. The gRPC adapter layer adds minimal complexity while enabling gateway integration. All existing mcp-binance-rs code remains unchanged, preserving its simplicity and adhering to established patterns.

---

## Phase Completion Status

- ✅ **Phase 0: Research** - Complete (research.md created with 12 technology decisions)
- ✅ **Phase 1: Design** - Complete (data-model.md, quickstart.md, contracts/README.md created)
- ⏭️ **Phase 2: Task Breakdown** - Next step: Run `/speckit.tasks` to generate tasks.md

**Artifacts Created**:
1. `/specs/002-binance-provider-integration/plan.md` - This file
2. `/specs/002-binance-provider-integration/research.md` - Technology decisions
3. `/specs/002-binance-provider-integration/data-model.md` - Entity definitions (10 entities)
4. `/specs/002-binance-provider-integration/quickstart.md` - Developer setup guide
5. `/specs/002-binance-provider-integration/contracts/README.md` - gRPC contract documentation

**Ready for**: `/speckit.tasks` command to generate implementation task breakdown
